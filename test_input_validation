import unittest
from unittest.mock import patch
import builtins


class DummySource:
    """
    Simple stub object to simulate a client/card with a balance.
    """
    def __init__(self, balance: float):
        self.balance = balance


class DummyRepo:
    """
    Stub repo â€“ adjust methods to match your real implementation.
    We just track whether a transfer was attempted.
    """
    def __init__(self):
        self.transfer_called = False
        self.last_args = None

    def transfer(self, source_obj, target_card_num, amount):
        self.transfer_called = True
        self.last_args = (source_obj, target_card_num, amount)


class TestInputValidation(unittest.TestCase):
    """
    #TestInputValidation
    Tests for validating user-entered transfer amounts.
    """

    def setUp(self):
        self.source = DummySource(balance=100.0)
        self.repo = DummyRepo()

    @patch.object(builtins, "input", return_value="abc")
    def test_rejects_non_numeric_amount(self, mocked_input):
        """
        When the user enters a non-numeric amount (e.g. 'abc'),
        transfer_money should NOT perform a transfer and should
        handle the error without crashing.
        """
        # Should not raise an exception
        transfer_money(self.source, self.repo)
        self.assertFalse(self.repo.transfer_called, "Transfer should not be called for non-numeric input")
        self.assertEqual(self.source.balance, 100.0)

    @patch.object(builtins, "input", return_value="-50")
    def test_rejects_negative_amount(self, mocked_input):
        """
        Negative amounts should be rejected and no transfer executed.
        """
        transfer_money(self.source, self.repo)
        self.assertFalse(self.repo.transfer_called, "Transfer should not be called for negative amounts")
        self.assertEqual(self.source.balance, 100.0)

    @patch.object(builtins, "input", return_value="0")
    def test_rejects_zero_amount(self, mocked_input):
        """
        Zero amount is not a valid transfer value.
        """
        transfer_money(self.source, self.repo)
        self.assertFalse(self.repo.transfer_called, "Transfer should not be called for zero amount")
        self.assertEqual(self.source.balance, 100.0)

    @patch.object(builtins, "input", return_value="200")
    def test_rejects_amount_greater_than_balance(self, mocked_input):
        """
        Amount larger than the available balance should be rejected.
        """
        transfer_money(self.source, self.repo)
        self.assertFalse(self.repo.transfer_called, "Transfer should not be called if amount > balance")
        # Balance should be unchanged
        self.assertEqual(self.source.balance, 100.0)

    @patch.object(builtins, "input", return_value="50")
    def test_accepts_valid_amount(self, mocked_input):
        """
        Valid, positive amount within balance should be accepted.
        This test assumes that transfer_money either:
        - Calls repo.transfer(...), OR
        - Directly updates source_obj.balance.
        We assert at least one of those effects.
        """
        transfer_money(self.source, self.repo)

        # At least one of these should be true in your implementation.
        transfer_called = self.repo.transfer_called
        balance_updated = (self.source.balance == 50.0)

        self.assertTrue(
            transfer_called or balance_updated,
            "Expected either repo.transfer to be called or balance to be updated."
        )


if __name__ == "__main__":
    unittest.main()