<button id="runBtn" onclick="startProgram()">Run Program</button>
<div id="terminal" tabindex="0"></div>

<script>
    let started = false;

    // Function to calculate optimal terminal dimensions
    function getTerminalDimensions() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        let cols = 80;
        let rows = 24;
        
        // Adjust columns based on screen width
        if (width < 380) {
            cols = 40;
            rows = 20;
        } else if (width < 480) {
            cols = 50;
            rows = 22;
        } else if (width < 768) {
            cols = 60;
            rows = 24;
        } else if (width < 1024) {
            cols = 70;
            rows = 26;
        } else if (width >= 1440) {
            cols = 100;
            rows = 30;
        } else if (width >= 2560) {
            cols = 120;
            rows = 40;
        }
        
        // Adjust for landscape on mobile
        if (width < 768 && width > height) {
            rows = Math.floor(rows * 0.8);
        }
        
        return { cols, rows };
    }

    function startProgram() {
        if (started) return;
        started = true;

        // Show the terminal
        const terminalDiv = document.getElementById('terminal');
        terminalDiv.classList.add('active');

        const dimensions = getTerminalDimensions();
        var term = new Terminal({ 
            cols: dimensions.cols, 
            rows: dimensions.rows, 
            convertEol: true,
            scrollback: 1000,
            fontSize: getFontSize(),
            fontFamily: 'Courier New, monospace',
            theme: {
                background: '#000000',
                foreground: '#ffffff'
            }
        });

        term.open(document.getElementById('terminal'));
        term.focus();
        term.writeln('Running startup command: python run.py');
        term.writeln('');

        var ws = new WebSocket(location.protocol.replace('http', 'ws') + '//' + location.hostname + (location.port ? (':' + location.port) : '') + '/');

        ws.onopen = function () {
            document.getElementById('runBtn').disabled = true;
            term.focus();
        };

        // Server -> terminal
        ws.onmessage = function (evt) {
            let text = '';
            if (typeof evt.data === 'string') {
                text = evt.data;
                term.write(text);
            } else if (evt.data instanceof ArrayBuffer) {
                text = new TextDecoder('utf-8').decode(new Uint8Array(evt.data));
                term.write(text);
            } else {
                var reader = new FileReader();
                reader.onload = function () { 
                    text = reader.result;
                    term.write(text); 
                };
                reader.readAsText(evt.data);
            }
            
            // Check if the received text contains PIN prompt
            // Look for patterns like "PIN: " at the end of the text
            if (text && (text.includes('PIN: ') || text.includes('Enter new PIN: ') || text.includes('Confirm new PIN: ') || text.includes('Enter current PIN: '))) {
                isPinMode = true;
            }
        };

        ws.onerror = function (e) { console.log(e); };
        ws.onclose = function () {
            term.write('\r\n[Session closed]\r\n');
            document.getElementById('runBtn').disabled = false;
            started = false;
            // Optionally hide terminal on close
            // document.getElementById('terminal').classList.remove('active');
        };

        // PIN masking state
        let isPinMode = false;
        let lastLine = '';

        // Simple local-echo line editor: buffer input, echo locally, send on Enter
        let line = '';
        term.onData(function (data) {
            if (ws.readyState !== WebSocket.OPEN) return;

            // Handle Enter (CR or LF)
            if (data === '\r' || data === '\n') {
                term.write('\r\n');
                ws.send(line + '\n');  // send the completed line
                line = '';
                isPinMode = false; // Reset PIN mode after submission
                return;
            }

            // Handle Ctrl+C
            if (data === '\x03') {
                term.write('^C\r\n');
                ws.send('\x03');
                line = '';
                isPinMode = false;
                return;
            }

            // Handle Backspace (DEL)
            if (data === '\x7f') {
                if (line.length > 0) {
                    line = line.slice(0, -1);
                    term.write('\b \b'); // move back, erase, move back
                }
                return;
            }

            // For pasted text or multi-char data, normalize CR to LF and split
            if (data.length > 1) {
                data = data.replace(/\r/g, '\n');
                for (const ch of data) {
                    if (ch === '\n') {
                        term.write('\r\n');
                        ws.send(line + '\n');
                        line = '';
                        isPinMode = false;
                    } else if (ch >= ' ') {
                        line += ch;
                        // Echo character based on PIN mode
                        if (isPinMode && ch >= '0' && ch <= '9') {
                            term.write('*');
                        } else if (!isPinMode) {
                            term.write(ch);
                        }
                    }
                }
                return;
            }

            // Printable characters
            if (data >= ' ') {
                line += data;
                // Echo character based on PIN mode
                if (isPinMode && data >= '0' && data <= '9') {
                    term.write('*');
                } else if (!isPinMode) {
                    term.write(data);
                }
            }
        });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                const newDimensions = getTerminalDimensions();
                try {
                    term.resize(newDimensions.cols, newDimensions.rows);
                    term.setOption('fontSize', getFontSize());
                } catch (e) {
                    console.log('Resize error:', e);
                }
            }, 250);
        });

        // Ensure focus
        const termEl = document.getElementById('terminal');
        termEl.addEventListener('click', () => term.focus());
        
        // Mobile touch support
        termEl.addEventListener('touchstart', function(e) {
            term.focus();
            e.preventDefault();
        });

        setTimeout(function () {
            var ta = document.getElementsByClassName("xterm-helper-textarea")[0];
            if (ta) ta.focus();
        }, 50);
    }

    // Get appropriate font size based on screen width
    function getFontSize() {
        const width = window.innerWidth;
        if (width < 380) return 9;
        if (width < 480) return 10;
        if (width < 768) return 11;
        if (width < 1024) return 13;
        if (width >= 2560) return 18;
        if (width >= 1440) return 15;
        return 14;
    }
</script>
